#include "doctest.h"
#include "qsc.hpp"

using namespace qsc;
using doctest::Approx;

/** Test that the curvature and torsion match an independent
 *  calculation using the fortran code.
*/
TEST_CASE("curvature and torsion: stellarator-symmetric case") {
  Qsc q;
  q.nfp = 5;
  q.nphi = 15;

  q.resize_axis_arrays(4, 0.0);

  q.R0c[0] = 1.3;
  q.R0c[1] = 0.3;
  q.R0c[2] = 0.01;
  q.R0c[3] = -0.001;

  q.Z0s[1] = 0.4;
  q.Z0s[2] = -0.02;
  q.Z0s[3] = -0.003;

  q.allocate();
  q.init_axis();

  qscfloat d_l_d_phi0_fortran[] = {2.380946450468805, 2.401491603596588, 2.37739502011906 ,
       2.195045899072531, 1.946968810010707, 1.916183968203471,
       2.142191459922493, 2.350113816182883, 2.350113816182884,
       2.142191459922493, 1.916183968203471, 1.946968810010706,
       2.195045899072531, 2.377395020119059, 2.401491603596588};
  
  qscfloat curvature_fortran[] = {1.74354628565018, 1.61776632275718, 1.5167042487094,
    1.9179603622369, 2.95373444883134, 3.01448808361584, 1.7714523990583,
    1.02055493647363, 1.02055493647363, 1.77145239905828, 3.01448808361582,
    2.95373444883135, 1.91796036223691, 1.5167042487094, 1.61776632275717};

  qscfloat torsion_fortran[] = {0.257226801231061, -0.131225053326418, -1.12989287766591,
    -1.72727988032403, -1.48973327005739, -1.34398161921833,
    -1.76040161697108, -2.96573007082039, -2.96573007082041,
    -1.7604016169711, -1.34398161921833, -1.48973327005739,
    -1.72727988032403, -1.12989287766593, -0.13122505332643};

  qscfloat varphi_fortran[] = {0, 0.0909479184372571, 0.181828299105257,
    0.268782689120682, 0.347551637441381, 0.42101745128188,
    0.498195826255542, 0.583626271820683, 0.673010789615233,
    0.758441235180374, 0.835619610154036, 0.909085423994535,
    0.987854372315234, 1.07480876233066, 1.16568914299866};

  for (int j = 0; j < q.nphi; j++) {
    CHECK(q.d_l_d_phi0[j] == Approx(d_l_d_phi0_fortran[j]));
    CHECK(q.curvature[j] == Approx(curvature_fortran[j]));
    CHECK(q.torsion[j] == Approx(torsion_fortran[j]));
    CHECK(q.Boozer_toroidal_angle[j] == Approx(varphi_fortran[j]));
  }
}

TEST_CASE("curvature and torsion: non-stellarator-symmetric case") {
  Qsc q;
  q.nfp = 5;
  q.nphi = 15;
  
  q.resize_axis_arrays(4, 0.0);

  q.R0c[0] = 1.3;
  q.R0c[1] = 0.3;
  q.R0c[2] = 0.01;
  q.R0c[3] = -0.001;

  q.Z0s[1] = 0.4;
  q.Z0s[2] = -0.02;
  q.Z0s[3] = -0.003;

  q.R0s[1] = -0.1;
  q.R0s[2] = -0.03;
  q.R0s[3] = 0.002;

  q.Z0c[0] = 0.3;
  q.Z0c[1] = 0.2;
  q.Z0c[2] = 0.04;
  q.Z0c[3] = 0.004;

  q.allocate();
  q.init_axis();

  qscfloat curvature_fortran[] = {2.10743037699653, 2.33190181686696, 1.83273654023051,
    1.81062232906827, 2.28640008392347, 1.76919841474321, 0.919988560478029,
    0.741327470169023, 1.37147330126897, 2.64680884158075, 3.39786486424852,
    2.47005615416209, 1.50865425515356, 1.18136509189105, 1.42042418970102};

  qscfloat torsion_fortran[] = {-0.167822738386845, -0.0785778346620885, -1.02205137493593,
    -2.05213528002946, -0.964613202459108, -0.593496282035916,
    -2.15852857178204, -3.72911055219339, -1.9330792779459,
    -1.53882290974916, -1.42156496444929, -1.11381642382793,
    -0.92608309386204, -0.868339812017432, -0.57696266498748};

  qscfloat varphi_fortran[] = {0, 0.084185130335249, 0.160931495903817,
    0.232881563535092, 0.300551168190665, 0.368933497012765,
    0.444686439112853, 0.528001290336008, 0.612254611059372,
    0.691096975269652, 0.765820243301147, 0.846373713025902,
    0.941973362938683, 1.05053459351092, 1.15941650366667};
  
  for (int j = 0; j < q.nphi; j++) {
    CHECK(q.curvature[j] == Approx(curvature_fortran[j]));
    CHECK(q.torsion[j] == Approx(torsion_fortran[j]));
    CHECK(q.Boozer_toroidal_angle[j] == Approx(varphi_fortran[j]));
  }
}

/** For a case in which the angle shift is nonzero, compare the
    curvature and torsion to an independent calculation in
    20220916-01_axis_angle_shift_benchmark.jl
*/
TEST_CASE("curvature and torsion: including angle shift") {
  Qsc q;
  q.nfp = 3;
  q.nphi = 15;

  q.resize_axis_arrays(4, 0.0);

  q.R0c[0] = 1.1;
  q.R0c[1] = 0.2;
  q.R0c[2] = 0.02;
  q.R0c[3] = 0.002;

  q.R0s[1] = 0.1;
  q.R0s[2] = 0.01;
  q.R0s[3] = 0.001;

  q.Z0c[0] = 0.6;
  q.Z0c[1] = 0.06;
  q.Z0c[2] = 0.006;
  q.Z0c[3] = 0.0006;

  q.Z0s[1] = 0.3;
  q.Z0s[2] = 0.03;
  q.Z0s[3] = 0.003;

  q.fc[0] = 0.5;
  q.fc[1] = 0.05;
  q.fc[2] = 0.005;
  q.fc[3] = 0.0005;

  q.fs[1] = 0.4;
  q.fs[2] = 0.04;
  q.fs[3] = 0.004;

  q.allocate();
  q.init_axis();

  qscfloat phi_julia[] = {0.5555, 0.8850284508852546, 1.1511720068383684, 1.3314631523289147, 1.4342307724177394, 1.4829008461601298, 1.4998828510379567, 1.5018865714844014, 1.5030202084174644, 1.5170097388558683, 1.5574942562330658, 1.6402390246357275, 1.784934462563651, 2.0082818545636614, 2.3077215203301646};
  
  qscfloat d_l_d_phi0_julia[] = {3.4750423862140156, 3.0539598608872947, 2.1806756226600963, 1.3696774124706803, 0.9728475048586671, 0.8957493959281542, 0.8825869836865875, 0.8329245809341502, 0.7302182851052049, 0.609712186841811, 0.5983090141911175, 0.8981080437530583, 1.5461952798537613, 2.412481793477508, 3.1934097612092467};

  qscfloat curvature_julia[] = {0.898084091586719, 1.0123990658850295, 1.4904560916366625, 2.996831175208578, 4.355331379142232, 2.87114741935169, 1.6471120045905918, 1.4547957038209085, 2.457722959942484, 5.590955246181348, 8.362315722903562, 3.8315723130771793, 1.5881614651600262, 1.096256830289683, 0.9326995618375906};

  qscfloat torsion_julia[] = {0.1702837931441043, -0.0064304031355428976, -0.6070891290953383, -1.436322255843183, -1.8660130581519108, -2.5700230656711667, -4.326996565875484, -5.665397004221713, -4.064541844487797, -3.2748309979731514, -3.7404376040332967, -4.402610985873702, -2.431606482843342, -0.3882928266142598, 0.12125816129640325};
  
  for (int j = 0; j < q.nphi; j++) {
    CAPTURE(j);
    CHECK(q.phi[j] == Approx(phi_julia[j]));
    CHECK(q.d_l_d_phi0[j] == Approx(d_l_d_phi0_julia[j]));
    CHECK(q.curvature[j] == Approx(curvature_julia[j]));
    CHECK(q.torsion[j] == Approx(torsion_julia[j]));
  }
}

